
# Алгоритм поиска в ширину (BFS) (без двухсторонней очереди)
DICT = {      # Матрица смежности
    'A':'BCD',
    'B':'E',
    'C':'B',
    'D':'G',
    'E':'',
    'F':'E',
    'G':'FA',
}

queue = ['A'] # Очередь
memory = {'A':None} # Посещаемые узлы(Убирает повторы, помогает восстановить кратчайший путь)

while True: # Используем бесконечный цикл, т.к будем принудительно завершать его
    NOW = queue[0] # Текущий узел
    sosedi = DICT[NOW] # Соседи текущего узла

    if NOW == 'E':break # Если нашли узлел-ломаем цикл
    for i in sosedi: # Перебираем соседей текущего узла
        if i not in memory:  # Проверям узел на повторы
            memory[i] = NOW # Вносим в хеш-функцию ребро:откуда пришли в это ребро
            queue.append(i) # Доавляем соседа в очередь

    queue.remove(NOW)

# Процесс восстановления пути
END = 'E'
way = []

while END != None:
    way.append(END)
    END = memory[END]

print(way[::-1])
